package com.example.morefit.ui.activity

import android.Manifest
import android.app.AlertDialog
import android.app.Dialog
import android.content.pm.PackageManager
import android.graphics.Color
import android.graphics.drawable.ColorDrawable
import android.os.Bundle
import android.os.Handler
import android.os.Process
import android.view.*
import android.widget.*
import androidx.activity.result.contract.ActivityResultContracts
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.SwitchCompat
import androidx.core.content.ContextCompat
import androidx.fragment.app.DialogFragment
import androidx.lifecycle.lifecycleScope
import com.example.energybar.ContentViewModel
import com.example.energybar.WordViewModelFactory
import com.example.energybar.database.ContentApplication
import com.example.morefit.R
import com.example.morefit.model.database.Content
import com.example.morefit.ui.fragment.dash.gym.ExerciseFragment
import com.example.morefit.utils.Datastore
import com.google.android.material.card.MaterialCardView
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch
import org.tensorflow.lite.examples.poseestimation.camera.CameraSource
import org.tensorflow.lite.examples.poseestimation.data.Device
import org.tensorflow.lite.examples.poseestimation.ml.*
import java.util.*

class RepCounterActivity : AppCompatActivity() {
    companion object {
        private const val FRAGMENT_DIALOG = "dialog"
        var correct_label = ""
    }

    private val contentViewModel: ContentViewModel by viewModels() {
        WordViewModelFactory((application as ContentApplication).repository)
    }

    /** A [SurfaceView] for camera preview.   */
    private lateinit var surfaceView: SurfaceView
    var counterStart = false

    /** Default pose estimation model is 1 (MoveNet Thunder)
     * 0 == MoveNet Lightning model
     * 1 == MoveNet Thunder model
     * 2 == MoveNet MultiPose model
     * 3 == PoseNet model
     **/

    private var modelPos = 1
    var first = 0;
    var time: Long = 0

    /** Default device is CPU */
    private var device = Device.CPU

    //Clock
    private var seconds = 0

    // Is the stopwatch running?
    private var running = false

    private var wasRunning = false


    var counter = 0
    lateinit var completeRep: ImageButton
    private lateinit var tvScore: TextView
    private lateinit var tvFPS: TextView
    private lateinit var spnDevice: Spinner
    private lateinit var spnModel: Spinner
    private lateinit var spnTracker: Spinner
    private lateinit var vTrackerOption: View
    private lateinit var tvClassificationValue1: TextView
    private lateinit var tvClassificationValue2: TextView
    private lateinit var tvClassificationValue3: TextView
    private lateinit var swClassification: SwitchCompat
    private lateinit var cardview: MaterialCardView
    private lateinit var vClassificationOption: View
    private lateinit var startTimer: ImageButton
    private lateinit var resetTimer: ImageButton
    private lateinit var repcountText: TextView
    private lateinit var datastore: Datastore
    private var cameraSource: CameraSource? = null
    private var isClassifyPose = false
    private val requestPermissionLauncher =
        registerForActivityResult(
            ActivityResultContracts.RequestPermission()
        ) { isGranted: Boolean ->
            if (isGranted) {
                // Permission is granted. Continue the action or workflow in your
                // app.
                openCamera()
            } else {
                // Explain to the user that the feature is unavailable because the
                // features requires a permission that the user has denied. At the
                // same time, respect the user's decision. Don't link to system
                // settings in an effort to convince the user to change their
                // decision.
                ErrorDialog.newInstance(getString(R.string.tfe_pe_request_permission))
                    .show(supportFragmentManager, FRAGMENT_DIALOG)
            }
        }
    private var changeModelListener = object : AdapterView.OnItemSelectedListener {
        override fun onNothingSelected(parent: AdapterView<*>?) {
            // do nothing
        }

        override fun onItemSelected(
            parent: AdapterView<*>?,
            view: View?,
            position: Int,
            id: Long
        ) {
            changeModel(position)
        }
    }

    private var changeDeviceListener = object : AdapterView.OnItemSelectedListener {
        override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
            changeDevice(position)
        }

        override fun onNothingSelected(parent: AdapterView<*>?) {
            // do nothing
        }
    }

    private var changeTrackerListener = object : AdapterView.OnItemSelectedListener {
        override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
            changeTracker(position)
        }

        override fun onNothingSelected(parent: AdapterView<*>?) {
            // do nothing
        }
    }

    private var setClassificationListener =
        CompoundButton.OnCheckedChangeListener { _, isChecked ->
            showClassificationResult(isChecked)
            isClassifyPose = isChecked
            isPoseClassifier()
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_rep_counter)
        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        cardview = findViewById(R.id.materialCardView1)
        tvScore = findViewById(R.id.tvScore)
        tvFPS = findViewById(R.id.tvFps)
        spnModel = findViewById(R.id.spnModel)
        spnDevice = findViewById(R.id.spnDevice)
        spnTracker = findViewById(R.id.spnTracker)
        startTimer = findViewById(R.id.startTimer)
        repcountText = findViewById(R.id.RepCount01)
        resetTimer = findViewById(R.id.ressetTimer)
        vTrackerOption = findViewById(R.id.vTrackerOption)
        surfaceView = findViewById(R.id.surfaceView1)
        tvClassificationValue1 = findViewById(R.id.tvClassificationValue1)
        tvClassificationValue2 = findViewById(R.id.tvClassificationValue2)
        tvClassificationValue3 = findViewById(R.id.tvClassificationValue3)
        swClassification = findViewById(R.id.swPoseClassification)
        vClassificationOption = findViewById(R.id.vClassificationOption)
        completeRep = findViewById(R.id.completerep)
        var title = findViewById<TextView>(R.id.Title1)
        title.text = ExerciseFragment.name
        initSpinner()
        spnModel.setSelection(modelPos)
        swClassification.setOnCheckedChangeListener(setClassificationListener)
        if (savedInstanceState != null) {

            // Get the previous state of the stopwatch
            // if the activity has been
            // destroyed and recreated.
            seconds = savedInstanceState
                .getInt("seconds")
            running = savedInstanceState
                .getBoolean("running")
            wasRunning = savedInstanceState
                .getBoolean("wasRunning")
        }

        val dialodView =
            LayoutInflater.from(this).inflate(R.layout.fragment_lets_go, null)
        val mBuilder = AlertDialog.Builder(this)
            .setView(dialodView)
        val alertDialog: AlertDialog = mBuilder.create()
        alertDialog.getWindow()?.requestFeature(Window.FEATURE_NO_TITLE)
        alertDialog.show()
        alertDialog.window?.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))

        Handler().postDelayed({
            dialodView.findViewById<TextView>(R.id.textloader).text = "2"
        }, 1000)
        Handler().postDelayed({
            dialodView.findViewById<TextView>(R.id.textloader).text = "1"
        }, 2000)
        Handler().postDelayed({
            dialodView.findViewById<TextView>(R.id.textloader).text = "Lets'Go"
        }, 3000)

        Handler().postDelayed({
            alertDialog.cancel()
            counter=0
        }, 4000)
        runTimer()
        completeRep.setOnClickListener {
            var content = arrayListOf<Content>(
                Content(
                    System.currentTimeMillis(), ExerciseFragment.name,
                    seconds.toLong(), counter
                )
            )
            contentViewModel.insert(content)

            datastore = Datastore(this)

            // Streak
            GlobalScope.launch {
                if ((System.currentTimeMillis() - datastore.getLastWorkoutDate()) > 86400000
                    && (System.currentTimeMillis() - datastore.getLastWorkoutDate()) < 172800000
                ) {
                    datastore.setStreakCount(datastore.getStreakCount() + 1)
                    datastore.setLastWorkoutDate(System.currentTimeMillis())
                } else if ((System.currentTimeMillis() - datastore.getLastWorkoutDate()) > 172800000) {
                    datastore.setStreakCount(1)
                    datastore.setLastWorkoutDate(System.currentTimeMillis())
                } else if ((System.currentTimeMillis() - datastore.getLastWorkoutDate()) < 86400000) {
                    datastore.setLastWorkoutDate(System.currentTimeMillis())
                }
            }

        }
        startTimer.setOnClickListener {

            if (counterStart) {
                running = false
                startTimer.setImageResource(R.drawable.ic_baseline_play_arrow_24)
                counterStart = false
            } else {
                startTimer.setImageResource(R.drawable.ic_baseline_pause_24)
                resetTimer.visibility = View.VISIBLE
                running = true
                counterStart = true
            }
        }
        resetTimer.setOnClickListener {
            running = false
            counter = 0
            seconds = 0
            resetTimer.visibility = View.INVISIBLE
        }
        if (!isCameraPermissionGranted()) {
            requestPermission()
        }
        cameraSource?.setClassifier(PoseClassifier.create(this))
    }

    private fun runTimer() {
        // Get the text view.
        // Get the text view.
        val timeView = findViewById<View>(
            R.id.time_view1
        ) as TextView

        // Creates a new Handler

        // Creates a new Handler
        val handler = Handler()
        handler.post(object : Runnable {
            override fun run() {
                val hours = seconds / 3600
                val minutes = seconds % 3600 / 60
                val secs = seconds % 60

                // Format the seconds into hours, minutes,
                // and seconds.
                val time: String = java.lang.String
                    .format(
                        Locale.getDefault(),
                        "%d:%02d:%02d", hours,
                        minutes, secs
                    )

                // Set the text view text.
                timeView.text = time

                // If running is true, increment the
                // seconds variable.
                if (running) {
                    seconds++
                }

                // Post the code again
                // with a delay of 1 second.
                handler.postDelayed(this, 1000)
            }
        })
        // Call the post() method,
        // passing in a new Runnable.
        // The post() method processes
        // code without a delay,
        // so the code in the Runnable
        // will run almost immediately.
    }

    override fun onStart() {
        super.onStart()
        openCamera()
    }

    override fun onResume() {
        cameraSource?.resume()
        super.onResume()
        if (wasRunning) {
            running = true;
        }

    }

    override fun onPause() {
        cameraSource?.close()
        cameraSource = null
        super.onPause()
        wasRunning = running;
        running = false;
    }

    // check if permission is granted or not.
    private fun isCameraPermissionGranted(): Boolean {
        return checkPermission(
            Manifest.permission.CAMERA,
            Process.myPid(),
            Process.myUid()
        ) == PackageManager.PERMISSION_GRANTED
    }

    // open camera
    private fun openCamera() {
        if (isCameraPermissionGranted()) {
                if (cameraSource == null) {
                    cameraSource =
                        CameraSource(surfaceView, object : CameraSource.CameraSourceListener {
                            override fun onFPSListener(fps: Int) {
                                tvFPS.text = getString(R.string.tfe_pe_tv_fps, fps)
                            }

                            override fun onDetectedInfo(
                                personScore: Float?,
                                poseLabels: List<Pair<String, Float>>?
                            ) {

                                tvScore.text =
                                    getString(R.string.tfe_pe_tv_score, personScore ?: 0f)
                                poseLabels?.sortedByDescending { it.second }?.let {
                                    for (i in it) {
//                                runOnUiThread{
//                                    repcountText.text=it.toString()
//                                }
                                        if (correct_label == i.first) {
                                            if (i.second >= 0.80) {
                                                if (first == 0) {
                                                    time = System.currentTimeMillis()
                                                }
                                                first++;
                                                runOnUiThread {
//                                                Toast.makeText(this@RepCounterActivity, it.toString(), Toast.LENGTH_SHORT).show()
                                                    cardview.strokeColor =
                                                        Color.parseColor("#00FF00")
                                                }
                                            } else {
                                                first = 0
                                                if (((System.currentTimeMillis() - time) > 1000) && (time != 0L)) {
                                                    counter++
                                                }
                                                time = 0
                                                runOnUiThread {
                                                    repcountText.text = counter.toString()
                                                    cardview.strokeColor =
                                                        Color.parseColor("#FF0000")
                                                }
                                            }
                                        }
                                    }
                                    tvClassificationValue1.text = getString(
                                        R.string.tfe_pe_tv_classification_value,
                                        convertPoseLabels(if (it.isNotEmpty()) it[0] else null)
                                    )

                                    tvClassificationValue2.text = getString(
                                        R.string.tfe_pe_tv_classification_value,
                                        convertPoseLabels(if (it.size >= 2) it[1] else null)
                                    )
                                    tvClassificationValue3.text = getString(
                                        R.string.tfe_pe_tv_classification_value,
                                        convertPoseLabels(if (it.size >= 3) it[2] else null)
                                    )
                                }
                            }

                        }).apply {
                            prepareCamera()
                        }
                    isPoseClassifier()
                    lifecycleScope.launch(Dispatchers.Main) {
                        cameraSource?.initCamera()
                    }
                }
                createPoseEstimator()
        }



    }

    private fun convertPoseLabels(pair: Pair<String, Float>?): String {
        if (pair == null) return "empty"
        return "${pair.first} (${String.format("%.2f", pair.second)})"
    }

    private fun isPoseClassifier() {
        cameraSource?.setClassifier(PoseClassifier.create(this))
    }

    // Initialize spinners to let user select model/accelerator/tracker.
    private fun initSpinner() {
        ArrayAdapter.createFromResource(
            this,
            R.array.tfe_pe_models_array,
            android.R.layout.simple_spinner_item
        ).also { adapter ->
            // Specify the layout to use when the list of choices appears
            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
            // Apply the adapter to the spinner
            spnModel.adapter = adapter
            spnModel.onItemSelectedListener = changeModelListener
        }

        ArrayAdapter.createFromResource(
            this,
            R.array.tfe_pe_device_name, android.R.layout.simple_spinner_item
        ).also { adaper ->
            adaper.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)

            spnDevice.adapter = adaper
            spnDevice.onItemSelectedListener = changeDeviceListener
        }

        ArrayAdapter.createFromResource(
            this,
            R.array.tfe_pe_tracker_array, android.R.layout.simple_spinner_item
        ).also { adaper ->
            adaper.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)

            spnTracker.adapter = adaper
            spnTracker.onItemSelectedListener = changeTrackerListener
        }
    }

    // Change model when app is running
    private fun changeModel(position: Int) {
        if (modelPos == position) return
        modelPos = position
        createPoseEstimator()
    }

    // Change device (accelerator) type when app is running
    private fun changeDevice(position: Int) {
        val targetDevice = when (position) {
            0 -> Device.CPU
            1 -> Device.GPU
            else -> Device.NNAPI
        }
        if (device == targetDevice) return
        device = targetDevice
        createPoseEstimator()
    }

    // Change tracker for Movenet MultiPose model
    private fun changeTracker(position: Int) {
        cameraSource?.setTracker(
            when (position) {
                1 -> TrackerType.BOUNDING_BOX
                2 -> TrackerType.KEYPOINTS
                else -> TrackerType.OFF
            }
        )
    }

    private fun createPoseEstimator() {
        // For MoveNet MultiPose, hide score and disable pose classifier as the model returns
        // multiple Person instances.
        val poseDetector = when (modelPos) {
            0 -> {
                // MoveNet Lightning (SinglePose)
                showPoseClassifier(true)
                showDetectionScore(true)
                showTracker(false)
                MoveNet.create(this, device, ModelType.Lightning)
            }
            1 -> {
                // MoveNet Thunder (SinglePose)
                showPoseClassifier(true)
                showDetectionScore(true)
                showTracker(false)
                MoveNet.create(this, device, ModelType.Thunder)
            }
            2 -> {
                // MoveNet (Lightning) MultiPose
                showPoseClassifier(false)
                showDetectionScore(false)
                // Movenet MultiPose Dynamic does not support GPUDelegate
                if (device == Device.GPU) {
                    showToast(getString(R.string.tfe_pe_gpu_error))
                }
                showTracker(true)
                MoveNetMultiPose.create(
                    this,
                    device,
                    Type.Dynamic
                )
            }
            3 -> {
                // PoseNet (SinglePose)
                showPoseClassifier(true)
                showDetectionScore(true)
                showTracker(false)
                PoseNet.create(this, device)
            }
            else -> {
                null
            }
        }
        poseDetector?.let { detector ->
            cameraSource?.setDetector(detector)
        }
    }

    // Show/hide the pose classification option.
    private fun showPoseClassifier(isVisible: Boolean) {
        vClassificationOption.visibility = if (isVisible) View.VISIBLE else View.GONE
        if (!isVisible) {
            swClassification.isChecked = false
        }
    }

    // Show/hide the detection score.
    private fun showDetectionScore(isVisible: Boolean) {
        tvScore.visibility = if (isVisible) View.VISIBLE else View.GONE
    }

    // Show/hide classification result.
    private fun showClassificationResult(isVisible: Boolean) {
        val visibility = if (isVisible) View.VISIBLE else View.GONE
        tvClassificationValue1.visibility = visibility
        tvClassificationValue2.visibility = visibility
        tvClassificationValue3.visibility = visibility
    }

    // Show/hide the tracking options.
    private fun showTracker(isVisible: Boolean) {
        if (isVisible) {
            // Show tracker options and enable Bounding Box tracker.
            vTrackerOption.visibility = View.VISIBLE
            spnTracker.setSelection(1)
        } else {
            // Set tracker type to off and hide tracker option.
            vTrackerOption.visibility = View.GONE
            spnTracker.setSelection(0)
        }
    }

    private fun requestPermission() {
        when (PackageManager.PERMISSION_GRANTED) {
            ContextCompat.checkSelfPermission(
                this,
                Manifest.permission.CAMERA
            ) -> {
                // You can use the API that requires the permission.
                openCamera()
            }
            else -> {
                // You can directly ask for the permission.
                // The registered ActivityResultCallback gets the result of this request.
                requestPermissionLauncher.launch(
                    Manifest.permission.CAMERA
                )
            }
        }
    }

    // If the activity is paused,
    // stop the stopwatch.


    // If the activity is resumed,
    // start the stopwatch
    // again if it was running previously.
    private fun showToast(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
    }

    override fun onSaveInstanceState(
        savedInstanceState: Bundle
    ) {
        super.onSaveInstanceState(savedInstanceState)
        savedInstanceState
            .putInt("seconds", seconds)
        savedInstanceState
            .putBoolean("running", running)
        savedInstanceState
            .putBoolean("wasRunning", wasRunning)
    }

    fun onClickStart() {
        running = true
    }

    // Stop the stopwatch running
    // when the Stop button is clicked.
    // Below method gets called
    // when the Stop button is clicked.
    fun onClickStop(view: View?) {
        running = false
    }

    // Reset the stopwatch when
    // the Reset button is clicked.
    // Below method gets called
    // when the Reset button is clicked.
    fun onClickReset(view: View?) {

    }

    /**
     * Shows an error message dialog.
     */
    class ErrorDialog : DialogFragment() {

        override fun onCreateDialog(savedInstanceState: Bundle?): Dialog =
            AlertDialog.Builder(activity)
                .setMessage(requireArguments().getString(ARG_MESSAGE))
                .setPositiveButton(android.R.string.ok) { _, _ ->
                    // do nothing
                }
                .create()

        companion object {

            @JvmStatic
            private val ARG_MESSAGE = "message"

            @JvmStatic
            fun newInstance(message: String): ErrorDialog = ErrorDialog().apply {
                arguments = Bundle().apply { putString(ARG_MESSAGE, message) }
            }
        }
    }
}